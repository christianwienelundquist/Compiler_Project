import org.antlr.v4.runtime.tree.ParseTreeVisitor;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;
import org.antlr.v4.runtime.CharStreams;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class main {
    public static void main(String[] args) throws IOException{

	// we expect exactly one argument: the name of the input file
	if (args.length!=1) {
	    System.err.println("\n");
	    System.err.println("Please give as input argument a filename\n");
	    System.exit(-1);
	}
	String filename=args[0];

	CharStream input = CharStreams.fromFileName(filename);
	ccLexer lex = new ccLexer(input);
	CommonTokenStream tokens = new CommonTokenStream(lex);
	ccParser parser = new ccParser(tokens);
	ParseTree parseTree = parser.start();
	ASTMaker astmaker = new ASTMaker();
	HTMLElementsStringss p=(HTMLElementsStringss)astmaker.visit(parseTree);
    }
}

// We write an interpreter that implements interface
// "implVisitor<T>" that is automatically generated by ANTLR
// This is parameterized over a return type "<T>" which is in our case
// simply a Double.
/*
inputs : 'inputs:' IDENTIFIER+;
outputs : 'outputs:' IDENTIFIER+;
latches : 'latches:' IDENTIFIER+;
def : 'def:' func_def+; 
updates : 'updates:' update+;
siminputs : 'siminputs:' siminput+;
*/




class ASTMaker extends AbstractParseTreeVisitor<AST> implements ccVisitor<AST> {
	public AST visitStart(ccParser.StartContext ctx){
		List<String> ps = new ArrayList<String>();
		ps.add((String) visit(ctx.hardwar));

		return new Start(ps);
	};
	
	public AST visitHardware(ccParser.HardwareContext ctx){
		List<String> ps = new ArrayList<String>();
		for (ccParser.HardwareContext s : ctx.hw)
			ps.add((String) visit(s));
		return new Hardware(ps);
	};

	public AST visitInputs(ccParser.InputsContext ctx){
		List<String> ps = new ArrayList<String>();
		for (ccParser.InputsContext s : ctx.inp)
			ps.add((String) visit(s));
		return new Input(ps);
	} 

	public AST visitOutputs(ccParser.OutputsContext ctx){
		List<String> ps = new ArrayList<String>();
		for (ccParser.OutputsContext s : ctx.otp)
			ps.add((String) visit(s));
		return new Output(ps);
		
		// return visit(ctx.otp);
		// return visit(ctx.otp);
	}

	public AST visitLatches(ccParser.LatchesContext ctx){
		List<String> ps = new ArrayList<String>();
		for (ccParser.LatchesContext s : ctx.lhes)
			ps.add((String) visit(s));
		return new latches(ps);
	}

	public AST visitDef(ccParser.DefContext ctx){
		List<String> ps = new ArrayList<String>();
		for (ccParser.DefContext s : ctx.df)
			ps.add((String) visit(s));
		return new latches(ps);
		// return visit(ctx.df);
	}

	public AST visitUpdates(ccParser.UpdatesContext ctx){
		List<String> ps = new ArrayList<String>();
		for (ccParser.UpdatesContext s : ctx.upd)
			ps.add((String) visit(s));
		return new latches(ps);
		// return visit(ctx.upd);
	}

	public AST visitSiminputs(ccParser.SiminputsContext ctx){
		List<String> ps = new ArrayList<String>();
		for (ccParser.SiminputsContext s : ctx.simip)
			ps.add((String) visit(s));
		return new latches(ps);
		// return visit(ctx.simip);
	}

	public AST visitUpdate(ccParser.UpdateContext ctx){
		return new Update((Exp) visit(ctx.e1),(Exp) visit(ctx.e2));
	}

	public AST visitSiminput(ccParser.SiminputContext ctx){
		return visit(ctx.c);
	}

	public AST visitFunc_def(ccParser.Func_defContext ctx){
		return visit(ctx.c);
	}



	public AST visitIdentifier(ccParser.IdentifierContext ctx){
		return visit(ctx.c);
	}


	public AST visitOscillator(ccParser.OscillatorContext ctx){
		return visit(ctx.c);
	}

	public AST visitFuncdef(ccParser.FuncdefContext ctx){
		return visit(ctx.c);
	}


	public AST visitAssign(ccParser.AssignContext ctx){
		return visit(ctx.c);
	}

	public AST visitFunctionCall(ccParser.FunctionCallContext ctx){
		return visit(ctx.c);
	}

	public AST visitParen(ccParser.ParenContext ctx){
		return visit(ctx.c);
	}

	
	public AST visitOR(ccParser.ORContext ctx){
		return new OR((Exp) visit(ctx.e1),(Exp) visit(ctx.e2));
		
	}

	public AST visitAND(ccParser.ANDContext ctx){
		return new And((Exp) visit(ctx.e1),(Exp) visit(ctx.e2));
	}

	public AST visitNOT(ccParser.NOTContext ctx){
		return new Not((Exp) visit(ctx.e1));
	}


}


// class Interpreter extends AbstractParseTreeVisitor<Double>
//                   implements ccVisitor<Double> {
//     // todo - Java will complain that "Interpreter" does not in fact
//     // implement "implVisitor" at the moment.

// 	public Double visitStart(ccParser.StartContext ctx){
		
// 		String htmlstring = "<!DOCTYPE html>
// 						<html><head><title>TITLEOFTHEPAGE</title>
// 						<script src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"></script>
// 						<script type=\"text/javascript\" id=\"MathJax-script\"
// 						async
// 						src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js\">
// 						</script></head><body>
// 						THEMAINTEXT
// 						</body></html>";
		
		
// 		System.out.println(htmlstring);
// 	    return visit(ctx.e);
// 	}
// 	public Double visitVariable(ccParser.VariableContext ctx){
// 	    System.err.println("Variables are not yet supported.\n");
// 	    System.exit(-1);
// 	    return null; }
// 	public Double visitAddSub(ccParser.AddSubContext ctx){
// 	    // e1=exp op=('+'|'-') e2=exp
// 	    System.out.println("Addition/Subtraction");
// 	    Double d1=visit(ctx.e1);
// 	    Double d2=visit(ctx.e2);
// 	    if (ctx.op.getText().equals("+")){
// 		System.out.println("Add "+d1+" + "+d2+" = "+(d1+d2));
// 		return d1+d2;
// 	    }
// 	    else{
// 		System.out.println("Sub "+d1+" - "+d2+" = "+(d1-d2));
// 		return d1-d2;
// 	    }
// 	}
// 	public Double visitConstant(ccParser.ConstantContext ctx){
// 	    String s=ctx.f.getText();
// 	    System.out.println("Constant "+ s);
// 	    return Double.valueOf(s);
// 	}
// 	public Double visitParen(ccParser.ParenContext ctx){ return visit(ctx.e); }
// 	public Double visitMultDiv(ccParser.MultDivContext ctx){
// 	    System.out.println("Mult/Div");
// 	    Double d1=visit(ctx.e1);
// 	    Double d2=visit(ctx.e2);
// 	    if (ctx.op.getText().equals("*")){
// 		System.out.println("Mult "+ d1 +" * "+ d2 +" = "+(d1 * d2));
// 		return d1*d2;
// 	    }
// 	    else{
// 		System.out.println("Div "+ d1 +" / "+ d2 +" = "+(d1 / d2));				
// 		return d1/d2;	
// 	    }
    
// 	}


// }

